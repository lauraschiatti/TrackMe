
 % PACKAGES
\documentclass[a4paper, hidelinks, 12pt]{report}
\usepackage[margin=1in]{geometry}
\usepackage{amsfonts,amsmath,amssymb}
\usepackage[none]{hyphenat}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{float}
\usepackage[nottoc,notlot,notlof]{tocbibind}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage[utf8]{inputenc}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[font=footnotesize]{caption}
\usepackage[flushleft]{threeparttable}
\usepackage{amsmath}
\usepackage{relsize}
\usepackage[super,negative]{nth}
\usepackage{enumerate}
\usepackage{float}
\usepackage{rotating}
\usepackage[dvipsnames]{xcolor}
\usepackage{listings}
%%%%%%%%%%%%

% DOC STYLES
\makeatletter
\def\thickhrulefill{\leavevmode \leaders \hrule height 1ex \hfill \kern \z@}
\def\@makechapterhead#1{
	\vspace*{4\p@}
	{\parindent \z@ \centering \reset@font
		\thickhrulefill\quad
		\scshape \@chapapp{} \thechapter
		\quad \thickhrulefill
		\par\nobreak
		\vspace*{4\p@}
		\interlinepenalty\@M
		\hrule
		\vspace*{4\p@}
		\Huge \bfseries #1\par\nobreak
		\par
		\vspace*{4\p@}
		\hrule
		\vskip 50\p@
}}
\def\@makeschapterhead#1{
	\vspace*{4\p@}
	{\parindent \z@ \centering \reset@font
		\thickhrulefill
		\par\nobreak
		\vspace*{4\p@}
		\interlinepenalty\@M
		\hrule
		\vspace*{4\p@}
		\Huge \bfseries #1\par\nobreak
		\par
		\vspace*{4\p@}
		\hrule
		\vskip 50\p@
}}

\pagestyle{fancy}
\fancyhead{}
\fancyfoot{}
\fancyhead[L]{\slshape\MakeUppercase{\textbf{DD}}}
\fancyhead[R]{\slshape{Avila, Schiatti, Virdi}}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{1pt}
\renewcommand{\headrulewidth}{1pt}
\linespread{1.3}
%\floatstyle{boxed}
\restylefloat{figure}
\parindent 0ex
%\renewcommand{baselinestretch}{1.5}

%%%%%%%%%%%%

% COMMANDS
\newcommand\requirement[1]{\item[{[R#1]}] }
\newcommand\goal[1]{\item[{[G#1]}] }
\newcommand\assumption[1]{\item[{[D#1]}] }
\newcommand\usecase[1]{ [UC#1] }

%%%%%%%%%%%%

%BODY
\begin{document}
	\begin{titlepage}
		\centering
		\vspace*{0.7 cm}
		\includegraphics[scale = 0.85]{../Assets/PolimiLogo.png}\\[1.6 cm]
		\textsc{\large Department of Computer Science and Engineering}\\[1.8 cm]
		
		\rule{\linewidth}{0.2 mm} \\[0.4 cm]
		{ \huge \bfseries Design Document (DD)}\\
		\rule{\linewidth}{0.2 mm} \\[1.5 cm]
		
		\textsc{\Large TrackMe}\\[0.5 cm]
		\textsc{\large - v1.1 -}\\[1 cm]
		
		\begin{minipage}{0.4\textwidth}
			\begin{flushleft} \large
				\emph{Authors:}\\
				\textbf{Avila}, Diego \\
				\textbf{Schiatti}, Laura \\
				\textbf{Virdi}, Sukhpreet
			\end{flushleft}
		\end{minipage}~
		\begin{minipage}{0.4\textwidth}
			\begin{flushright} \large
				%\emph{Student Number:} \\
				903988 \\
				904738 \\
				904204
			\end{flushright}
		\end{minipage}\\[2 cm]
		
		{\large January \nth{13} , 2019}\\[2 cm]
		
		\vfill
	\end{titlepage}
	
	\pagenumbering{roman}
	\tableofcontents
%	\thispagestyle{empty}
	\newpage
	\listoffigures
	\listoftables
%	\thispagestyle{empty}
	\clearpage
	\pagenumbering{arabic}
	\setcounter{page}{1}
	
	\chapter{Introduction}
	\section{Context}
	\textbf{TrackMe} develops health-monitoring devices devoted to measure and record different parameters related to the health status of a person (i.e. body temperature, blood pressure, heart pulse rate and percentage of O\textsubscript{2} in the blood) and also their location. TrackMe health smartwatches are synchronized with an app that gives users access to their data and stats. Also, TrackMe is offering new services to their customers, so as to exploit the data collected from those devices. 
	
	\section{Purpose}
	The requirements elicitation and analysis activities concerning the whole TrackMe system are presented with detail in the RASD (see \textbf{References} section). Then, the purpose of this document is to discuss more technical aspects regarding architectural and design choices that must be made, so as to follow well-oriented implementation and testing processes. \\
		
	More precisely, the document presents:
\begin{itemize}
		\item{}Overview of the high level architecture
		\item{}The main components and their interfaces provided one for another
		\item{}The runtime behavior
		\item{}The design patterns
		\item{} Implementation plan
		\item{}Integration plan
		\item{}Testing Plan
	\end{itemize}.
		
	\section{Scope}
	The TrackMe environment is composed by three systems whose scope can be summarized as follows: \\
	
	\textbf{D4H} is a system capable to provide third parties the health data collected from individuals that wear TrackMe devices. This is, third parties can request data of a single individual (who can accept or reject it), and also of groups of users. The data is available only  under certain conditions and is being retrieved anonymized.\\
	
	Additionally, \textbf{D4H} sends invitations to individuals older than 60 years that live in certain cities, offering them a personalized 24/7 monitoring service called \textbf{ASOS}. To establish which cities are available, D4H requests them to ASOS those cities in which there is at least one health care service that has a contract with TrackMe. If a user accepts to activate this service, D4H sends his basic information and last measured health status to ASOS. After receiving the data, ASOS stores it and assigns to the user an emergency contact according to his address. \\
			
	The system monitors individuals by comparing their health status with previously defined thresholds. If any of the parameters of a user is out of its normal range, a notification will be send to his associated health care service by means of a predefined communication
interface within the next five seconds. The health care service reaction time cannot be controlled by ASOS since it is out of the scope \\
	
	Finally, with \textbf{T4R} run organizers are able to setup runs, define their running circuit and send invitations to D4H users of their interest (i.e. according to some criteria), inviting them to participate in upcoming runs. The spectators are able to follow the participants' location using the T4R website. The location of every participant will only be available during the race.
	
	\section{Definitions, Acronyms, Abbreviations}
	\subsection{Definitions}
	\begin{itemize}
		\item{\textbf{Health status}}: Collection of the last measured overall physical health parameters of a user or a group of users.
		\item{\textbf{Running circuit}}: Path defined by the organizer for the run, using the set of nodes.
		\item{\textbf{Anonymize}}: The action of anonymize means that an individual’s identity cannot
be inferred using the available data.
		\item{\textbf{Parameter out of its normal range}}: Meaning that the parameter is under or above a defined threshold. 
		\item{\textbf{Filter}}
	\end{itemize}
	
	\subsection{Acronyms}
	\begin{itemize}
		\item{DD}: Design Document
		\item{RASD}: Requirement Analysis and Specification Document
		\item{D4H}: Data4Help
		\item{ASOS}: AutomatedSOS
		\item{T4R}: Track4Run
		\item{GUI}: Graphical User Interface
		\item{MVC}: Model View Controller 
	\end{itemize}
	
	\subsection{Abbreviations}
	\begin{itemize}
		\item $[Rn]$: n-requirement.
	\end{itemize}
	
	\section{Revision history}
	It is important to keep track of the revisions made to this document: \\
	
	\begin{table}[h]
		\centering
		\begin{tabular}{c c c}
			\hline\hline
			\textbf{Version} & \textbf{Last modified date} & \textbf{Comments} \\ [0.5ex]
			\hline
			1.0 &  \nth{11} November, 2018  & \\
			\hline
			1.1 &  \nth{13} January, 2019 & \textit{ (a)} \\
			\hline
		\end{tabular}
		\caption{Revision history timeline}
		\label{fig:Revision history}
	\end{table}
	
	\textit{ (a) } Update regarding diagrams looking forward to be precise with the actual implementation of the system.
	
	\section{Document structure}
	This document is divided in seven parts, each one devoted to approach each one of the steps required to apply requirements engineering techniques.
	\begin{itemize}
		\item Chapter 1 gives an introduction of the design document. It contains the purpose and the scope of the document, as well as some abbreviation in order to provide a better understanding of the document to the reader.
		\item Chapter 2  deals with the architectural design of the application. It gives an overview of the architecture
and it also contains the most relevant architecture views: component view, class view, deployment view, runtime view and it shows the interaction of the component interfaces. Some of the used architectural designs and designs patterns are also presented here, with an explanation of each one of them and the purpose of their usage.
		\item Chapter 3  refers to the mock-ups already presented in the RASD document.
		\item Chapter 4 explains how the requirements that have been defined in the RASD map to the design elements that are defined in this document.
		\item Chapter 5 presents the implementation, integration and test plan. It includes the how the different components of the application are integrated with each other, how they react, the testing strategy taken into account and analyse the risks in the application.
		\item Chapter 6 shows the effort spent by each group member while working on this project.
		\item Chapter 7 includes the reference documents.
	\end{itemize}
	
	\chapter{Architectural design}
	
	\section{Overview}
	\label{sec:overview}
	Application architecture design is a process which has to be executed in a defined flow. High-level components and their interaction is displayed in Figure \ref{fig:High-level architecture Diagram}.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/architecture.png}
		\caption[High-level architecture Diagram]{High-level architecture Diagram}
		\label{fig:High-level architecture Diagram}
	\end{figure}
	
	As can be seen in the Figure \ref{fig:High-level architecture Diagram}, there are three main systems, which are Data4Help, AutomatedSOS and Track4Run. Two of the systems have an MVC architecture in which they provide an interface to the web users (Individuals, Third Parties, Participants, Organizers, and Spectators), and the last one (AutomatedSOS) does not provide any interface to them. All the communications between Data4Help and the Third Parties are done via HTTP messages in a RESTful way. \\
	
	Finally, AutomatedSOS can be presented as an event-driven application, which receives the Individuals' information, and based on the defined thresholds it decides to contact or not the assigned emergency contact.

	\section{Component view}
		\subsection{Data4Help component diagram}
			\subsubsection{Overview}
		In the Figure \ref{fig:d4h_component_diagram} it can be seen the component diagram of D4H, with all its external interfaces. It can be noticed two main components: \textbf{DataBase} and \textbf{D4HBackend}, where the former one refers to the Data4Help database, and which provides an interface used by the \textbf{DBManager} component. \\
		
		On the other hand, \textbf{D4HBackend} component, contains all the components related to D4H, which are needed to provide the interfaces used by the third parties and the web site. The following interfaces are used by the web site: \textbf{SignupWeb}, \textbf{LoginWeb}, \textbf{SearchWeb}, \textbf{RequestWeb}, \textbf{UserWeb} and  \textbf{SubscriptionWeb}, while the \textbf{RequestAPI} interface is used by the third parties. In this case, D4H provides the interface in order to let the third parties send requests for accessing the health status and location of the individuals to them. Is it important to notice that the \textit{RequestPort} is used to show the difference between the interfaces that are consumed by Third Parties, and the interfaces used internally by the web site. The same can be noticed in the third party components, like Track4Run and AutomatedSOS, with their \textit{DataPort} and \textit{NotificationPort}.\\
		
		Furthermore, \textbf{AuthenticatorManager} component has the responsibility of validate the different credentials, and to provide the secret codes to the third parties, to do so, it interacts with the \textbf{TokenDB} component using the \textbf{TokenConnector}.\\
		
		Moreover, the \textbf{DataService} component has the responsibility of get the data from the TrackMe smart devices, and store them in the data base. The \textbf{Devices} component, make reference to all the TrackMe smart devices, which connect to the \textbf{DataService} component using an \textit{Internal} interface.\\
		
		Finally, it can be seen the different third parties related to D4H. It worth mentioning \textbf{Track4Run} and \textbf{AutomatedSOS} components which, even though they are part of the TrackMe environment, they are treated as third parties in the sense they are decoupled of D4H. Moreover, all third parties must provide an interface to D4H in order to let it communicate the incoming changes of the subscriptions.
	
			\begin{sidewaysfigure}
    				\centering
				\includegraphics[width=1\textwidth]{diagrams/d4h_component_diagram.png}
				\caption[Data4Help Component Diagram]{Data4Help Component Diagram}
				\label{fig:d4h_component_diagram}
			\end{sidewaysfigure}	
			\clearpage
			\subsubsection{Description}
			In the Table \ref{table:d4h_component_descriptions} a description of the components involved in D4H is shown.
			
		\begin{longtable}{l p{0.7\textwidth}}
			\hline\hline
			\multicolumn{2}{c}{\textbf{Component descriptions}} \\
			\hline
			\textbf{Component} & \textbf{Description} \\ [0.5ex]
			\hline
			\endfirsthead
			\hline
			\textbf{Component} & \textbf{Description} \\ [0.5ex]
			\hline
			\endhead
			Login & Component is responsible of the login and logout actions into the site. It provides the session access tokens to the users and removes them when the user performs a logout. \\
			
			Signup & Component responsible of register web-users, either Individuals or Third Party companies. It provides two different interfaces to the web-site, one for the Individual user and another one for the Third Party user, and provides a session access token and a secret key and application id to the Third Party users. \\
			
			SearchManager & Component responsible of handling the searches of Individuals or group of Individuals' information. It should be able to anonymize the information of the group of users, and to respond with an error message when the Third Party user tries to access an Individual's information who have not accepted the request. \\
			
			Request & Component responsible of adding the requests to a specific Individual and to accept or reject them. It should provide an internal interface, in order to send, accept and reject requests from within the web-site, and an external interface in order to let the Third Parties to send requests to specific users from their back-end. Finally, it should be capable of connecting to the notification API of the Third Parties in order to let them know that an Individual has accepted a Request.\\
			
			Subscription & Component responsible of sending the information of the users to the subscribed Third Parties. It should be able to connect to the Third Parties endpoints in order to send the information regarding the saved queries. Also, it should expose an internal interface in order to let the Third Party users to save a particular query, delete it or get all the saved queries.\\
			User & Component used by the front-end in order to get information about the current user (Individual or Third Party). Furthermore, it is responsible to get and store the changes in the profile of the current user, such as the Third Party configuration, which involve the URLs of the DataPort and NotificationPort\\
			
			Scheduler & This component contains two schedulers: the DataScheduler and the ASOSRequestScheduler. The first one, is responsible to send the data related to the subscriptions of bulk data, it runs at a fixed time rate (an hour). The DataScheduler looks for all the subscriptions that should be executed, makes a search using the saved query, anonymize the data, and sends it to the Third Party. The second scheduler, runs once a day, and is responsible to create the requests of ASOS to all the elderly individuals\\
			
			DBManager & Component responsible of connecting the database. It is related to all the other components since they depend on it.\\
			
			AuthenticatorManager & Component responsible of validate and generate the session access tokens, and to provide the secret key and application id to the Signup component.\\
			
			D4H Web site & Component that represent the frontier between the final user and the system. From this component, the Individual user is capable to accept or reject Requests, and the Third Party users are capable to search information of a particular Individual or a group of them, send Requests and/or creating subscriptions.\\
			
			DataBase & Component that contains the main database (TrackMe DB), with all its collections and the token database (TokenDB) which contains all the valid access tokens and secret keys.\\
			
			APIManager & Component responsible of connecting to the configured services of the Third Parties. It is responsible of sending the data of the subscriptions to the Third Parties, and of sending the notification of requests sent by the Third Party.\\
			
			\hline
			\caption{Component descriptions of D4H}
			\label{table:d4h_component_descriptions}
		\end{longtable}
			
			\subsection{AutomatedSOS component diagram}
				\subsubsection{Overview}
			In the Figure \ref{fig:asos_component_diagram} it can be seen the ASOS components. It can be noticed that the system has a similar structure of T4R: the \textbf{ASOSBackend} component communicates  with \textbf{DataBase} component through the \textbf{DBConnector} interface, and provides a \textbf{DataAPI} interface to receive the updated information of the individuals.\\\\
			On the other hand, \textbf{ASOSBackend} component sends notifications to the different \textbf{Health Care Service} components using the provided \textbf{Alarm Interface}.
			\begin{figure}[H]
				\centering
				\includegraphics[width=1\textwidth]{diagrams/asos_component_diagram.png}
				\caption[AutomatedSOS Component Diagram]{AutomatedSOS Component Diagram}
				\label{fig:asos_component_diagram}
			\end{figure}	
			\subsubsection{Description}
			In the Table \ref{table:asos_component_descriptions} a description of the components involved in ASOS is shown.
			
		\begin{longtable}{l p{0.7\textwidth}}
			\hline\hline
			\multicolumn{2}{c}{\textbf{Component descriptions}} \\
			\hline
			\textbf{Component} & \textbf{Description} \\ [0.5ex]
			\hline
			\endfirsthead
			\hline
			\textbf{Component} & \textbf{Description} \\ [0.5ex]
			\hline
			\endhead
			DBManager & Component responsible of connecting the database. It is related to all the other components since they depend on it.\\
			DataBase & Component that contains the main database (AutomatedSOS DB), with all its collections.\\
			DataService & Component responsible to get the location and health data of the Individuals every time it has changes. It should be able to obtain the information sent by D4H, and to get the information related to the Individuals who accepted the request. Moreover, it should be capable to get the Notifications every time an Individual approves or rejects a request.\\
			APIManager & Component responsible of connecting to the health-care service assigned to an Individual, when its parameters are out of normal range.\\
			\hline
			\caption{Component descriptions of ASOS}
			\label{table:asos_component_descriptions}
		\end{longtable}
		
	\subsection{Track4Run component diagram}
		\subsubsection{Overview}
			In the Figure \ref{fig:t4r_component_diagram} it can be seen the T4R components. As in the D4H component diagram, the \textit{DataBase} component provides an interface in order to let the \textbf{DBManager} component communicate to it.\\\\
			The main structure of the system is similar to the structure seen in D4H component diagram. The web site communicates with the back-end using the following interfaces: \textbf{LoginWeb}, \textbf{SignupWeb}, \textbf{UserWeb} and \textbf{NotificationWeb}. On the other hand, T4R provides the \textbf{DataAPI} interface, which is responsibly of receiving all the data of the participants, and uses the \textbf{RequestAPI} interface, in order to send the requests for accessing the individuals' location and health status.\\\\
			Finally, as in D4H, the \textbf{AuthenticatorManager} component is responsible of validate the users' credentials.
			\begin{figure}[H]
				\centering
				\includegraphics[width=1\textwidth]{diagrams/t4r_component_diagram.png}
				\caption[Track4Run Component Diagram]{Track4Run Component Diagram}
				\label{fig:t4r_component_diagram}
			\end{figure}	
			
			\subsubsection{Description}
			In the Table \ref{table:t4r_component_descriptions} a description of the components involved in T4R is shown.
			
		\begin{longtable}{l p{0.7\textwidth}}
			\hline\hline
			\multicolumn{2}{c}{\textbf{Component descriptions}} \\
			\hline
			\textbf{Component} & \textbf{Description} \\ [0.5ex]
			\hline
			\endfirsthead
			\hline
			\textbf{Component} & \textbf{Description} \\ [0.5ex]
			\hline
			\endhead
			Login & Component is responsible of the login and logout to the site. It provides the session access tokens to the users and removes them when the user performs a logout. \\
			Signup & Component responsible of register Participant and Organizer users. \\
			AuthenticatorManager & Component responsible of validate and generate the session access tokens.\\
			DBManager & Component responsible of connecting the database. It is related to all the other components since they depend on it.\\
			T4R Web site & Component that represent the frontier between the final user and the system. From this component, the Participant user is capable to enrol in a Run, and the Organizer users are capable to create Run events, define the running circuit and send invites to Participant users.\\
			DataBase & Component that contains the main database (Track4Run DB), with all its collections and the token database (TokenDB) which contains all the valid session access tokens.\\
			Request & Component responsible of sending Request for accessing location of a specific Individual in D4H. It should be able to connect to D4H through the provided RequestAPI.\\
			User & Component responsible of manage the Participant operations. It should be able to show all the enrolled and non-enrolled participants of a run.\\
			Event & Component responsible of manage the Event operations. It should be able to create running events, to define the running circuit, and to get all the available running events.\\
			Notification & Component responsible of manage the Notification operations. It should be able to send invitations to participants, and let them accept or reject it. \\
			DataHandler & Component responsible to get the location and health data of the Individuals during a Race event. It should be able to obtain the information sent by D4H during a race event, and to get the information related to the Individuals who accepted the sent request.\\
			
			\hline
			\caption{Component descriptions of T4R}
			\label{table:t4r_component_descriptions}
		\end{longtable}
		
	\section{Component interfaces}
	In the following section all the interfaces of the systems (D4H, T4R, ASOS) are presented. Furthermore, classes belonging to the components, in particular \textit{Service} classes count on methods that are related to the external interfaces. All the  exposed methods expected input parameters and the expected outputs wil be listed in this section.  \\
	
	The endpoints are categorized as \textit{setupWebEndpoints} or \textit{setupApiEndpoints} according to whether they are exposed for the web (front-end) or for third parties directly.  In this section interfaces exposed for the web are explained in detail.\\
	
	It is important to mention that \verb|Spark.Request| and \verb|Spark.Response| classes belong to the \textit{Java Spark Framework}, and does nothing to do with the \textit{D4HRequest} class of TrackMe system. 
		
	\subsection{Data4Help interfaces}	
	To have access to the exposed methods, it is required for requests to have the following HTTP headers to each request. 	The headers are required for all the methods except for \textit{login},  \textit{signupIndividual} and \textit{signupThirdParty}.\\
	\textbf{USER\_ID}= userId:String \\
	\textbf{ACCESS-TOKEN}= accessToken:String \\

	\begin{itemize}
		\item{\textbf{Login}}
			\begin{itemize}
	\item{\textbf{LoginService}}
		\begin{itemize}
			\item{\verb|LoginResponse login(Spark.Request req, Spark.Response response)|\\ \verb|POST /web/login|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} \textit{[LoginRequest]} & \textbf{Output} \textit{[UserWebAuth]} \\
			\hline
			\verb|email: String| & \verb|userId: String| \\
			\verb|password: String| & \verb|accessToken: String| \\
			& \verb|role: D4HUserRole| 
			\end{tabular}\\
			
			\item{\verb|String logout(Spark.Request req, Spark.Response response)|\\ \verb|POST /web/logout|}
			\item{\verb|String isValidToken(Spark.Request req, Spark.Response response)|\\ \verb|HEAD /web/|}
			\end{itemize}
				
		\item{\textbf{UserResource}}
			\begin{itemize}
				\item{\verb|D4HUser getByEmailAndPass(String email, String password)|}
				\item{\verb|ThirdParty getThirdPartyBySecretKey(String secretKey)|}
				\item{\verb|Individual getBySSN(String ssn)|}
				\item{\verb|List<Individual> getByQuery(D4HQuery query)|}
			\end{itemize}
	  \end{itemize}
			
			\item{\textbf{Signup}}
			\begin{itemize}
				\item{\textbf{SignupService}}
					\begin{itemize}
			\item{\verb|SignupResponse signupIndividual(Spark.Request req, Spark.Response res)|\\ \verb|POST /web/individual/signup|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} \textit{[IndividualSignupRequest]} & \textbf{Output} \textit{[UserWebAuth]}\\
			\hline
				\verb|email: String| & \verb|userId: String| \\
				\verb|password: String| & \verb|accessToken: String| \\
				\verb|name: String| & \verb|role: D4HUserRole| \\
				\verb|ssn: String| & \\
				\verb|birthDate: Date| & \\
				\verb|gender: Gender| & \\
				\verb|bloodType: BloodType| & \\
				\verb|weight: Float| & \\
				\verb|height: Float| & \\
				\verb|address: Address| & \\
				\verb|address.country: String| & \\
				\verb|address.province: String| & \\
				\verb|address.city: String| & \\
			\end{tabular}\\
			
			\item{\verb|SignupResponse signupThirdParty(Spark.Request req, Spark.Response res)|\\ \verb|POST /web/thirdparty/signup|}\\
			\begin{tabular}{l | l}
			\textbf{Input} \textit{[ThirdPartySignupRequest]} & \textbf{Output}\textit{[UserWebAuth]} \\
			\hline
				\verb|email: String| & \verb|userId: String| \\
				\verb|password: String| & \verb|accessToken: String| \\
				\verb|certificate: String| & \verb|role: D4HUserRole|  \\
				\verb|name: String| & \\
				\verb|phone: String| & \\
				\verb|taxCode: String| & \\
			\end{tabular}\\
		\end{itemize}
		\end{itemize}
			
			\item{\textbf{Search}}
			\begin{itemize}
				\item{\textbf{SearchService}}
				\begin{itemize}
			\item{\verb|Collection<Data> search(Spark.Request req,|\\ \verb|Spark.Response res)|\\ \verb|POST /web/search|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} \textit{[D4HQuery]} & \textbf{Output} \\
			\hline
				\verb|ssn: String| & \verb|ssn: String| \\
				& \verb|name: String| \\
				& \verb|data: Data| \\
				& \verb|data.location: Location| \\
				& \verb|data.location.longitude: Long| \\
				& \verb|data.location.latitude: Long| \\
				& \verb|data.healthStatus: HealthStatus| \\
				& \verb|data.healthStatus.heartRate: Integer| \\
				& \verb|data.healthStatus.healthStatus.systolic: Double| \\
				& \verb|data.healthStatus.healthStatus.diastolic: Double| \\
				& \verb|data.healthStatus.bodyTemperature: Double| \\
				& \verb|data.healthStatus.bloodOxygen: Integer| \\
			\hline
				\verb|country?: String| & \verb|data: List<Data>| \\
				\verb|city?: String| & \verb|data[*].healthStatus: HealthStatus| \\
				\verb|gender?: Gender| & \verb|data[*].healthStatus.heartRate: Integer| \\
				\verb|minAge?: Integer| & \verb|data[*].healthStatus.systolic: Double| \\
				\verb|maxAge?: Integer| & \verb|data[*].healthStatus.diastolic: Double| \\
				\verb|bloodType?: BloodType| & \verb|data[*].healthStatus.bodyTemperature: Double| \\
				\verb|province?: String| & \verb|data[*].healthStatus.bloodOxygen: Integer| \\
			\end{tabular}\\
		\end{itemize}	
						
				\item{\textbf{DataResource}}
					\begin{itemize}
						\item{\verb|Data getByIndividualId(Individual i)|}
						\item{\verb|Data getByIndividual(Individual individual)|}
						\item{\verb|Collection<Data> getByIndividualList(Collection<Individual> individuals)|}
						\item{\verb|Collection<Data> getAnonymizeByIndividualList(Collection<Individual> individuals)|}
					\end{itemize}
			\end{itemize}
			
		\item{\textbf{D4HRequest}}
			\begin{itemize}
				\item{\textbf{D4HRequestService}}
					\begin{itemize}
			\item{\verb|D4HReqResponse createRequest(Spark.Request req, Spark.Response res)|\\ \verb|POST /api/requests/|}\\
			\begin{tabular}{l | l}
			\textbf{Input} \textit{[D4HReqRequest]}  & \textbf{Output} \\
			\hline
				\verb|ssn: String| & \verb|requestId: String| \\
				& \verb|thirdParty: ThirdParty|\\
				& \verb|thirdParty.name: String|\\
				& \verb|individual: Individual|\\
				& \verb|individual.name: String|\\
				& \verb|status: D4HRequestStatus|\\
			\end{tabular}\\
			
			\item{\verb|D4HReqResponse updateRequestStatus(Spark.Request req, Spark.Response res)|\\ \verb|PATCH /web/requests/:requestId|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} \textit{[D4HReqRequest]} & \textbf{Output} \\
			\hline
				\verb|ssn: String| & \verb|id: String|\\
				\verb|status: D4HRequestStatus| & \verb|thirdParty: ThirdParty|\\
				& \verb|thirdParty.name: String|\\
				& \verb|individual: Individual|\\
				& \verb|individual.name: String|\\
				& \verb|status: D4HRequestStatus|\\
			\end{tabular}\\
			
			\item{\verb|Collection<D4HReqResponse> getAllRequests(Spark.Request req,|\\ \verb|Spark.Response res)|\\ \verb|GET /web/requests/:requestStatus|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				& \verb|requests: List<Request>| \\
				& \verb|requests[*].id: String| \\
				& \verb|requests[*].thirdParty: ThirdParty| \\
				& \verb|requests[*].thirdParty.name: String| \\
				& \verb|requests[*].individual: Individual| \\
				& \verb|requests[*].individual.name: String| \\
				& \verb|requests[*].status: D4HRequestStatus| \\
			\end{tabular}\\
		\end{itemize}		
				
				\item{\textbf{D4HRequestResource}}
					\begin{itemize}
						\item{\verb|Collection<D4HRequest> getById(String userId)|}
						\item{\verb|Collection<D4HRequest> getByUserId(String userId, D4HRequestStatus status)|}
						\item{\verb|Collection<D4HRequest> getByThirdPartyId(String thirdPartyId, D4HRequestStatus status)|}		
						\item{\verb|D4HRequest add(Request D4HRequest)|}
						\item{\verb|D4HRequest accept(D4HRequest r)|}
						\item{\verb|D4HRequest reject(D4HRequest r)|}
					\end{itemize}
			\end{itemize}	
			
			\item{\textbf{Subscription}}
			\begin{itemize}
				\item{\textbf{SubscriptionService}}
					\begin{itemize}
			\item{\verb|SubscriptionResponse createSubscription(Spark.Request req,|\\ \verb|Spark.Response res)|\\ \verb|POST /web/subscriptions/|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input}\textit{[SubscriptionRequest]} & \textbf{Output} \\
			\hline
				\verb|filter: D4HQuery| & \verb|subscriptionId: String| \\
				\verb|filter.ssn?: String| & \verb|filter: D4HQuery| \\
				\verb|filter.city?: String| & \verb|filter.ssn: String| \\
				\verb|filter.province?: String| &  \verb|filter.city: String| \\
				\verb|filter.country?: String| &  \verb|filter.province: String| \\
				\verb|filter.gender?: Gender| & \verb|filter.country: String| \\
				\verb|filter.minAge?: Integer| &  \verb|filter.gender: Gender| \\
				\verb|filter.maxAge?: Integer| &  \verb|filter.minAge: Integer| \\
				\verb|filter.bloodType?: BloodType| &  \verb|filter.maxAge: Integer| \\
				\verb|timeSpan: Integer| &  \verb|filter.bloodType: BloodType| \\
			\end{tabular}\\
                
			\item{\verb|Collection<Subscription> getAllSubscriptions(Spark.Request req,|\\ \verb|Spark.Response res)|\\ \verb|GET /web/subscriptions/|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				& \verb|subscriptions: List<Subscription>| \\
				& \verb|subscriptions[*].id: String| \\
				& \verb|filter: D4HQuery| \\
				& \verb|subscriptions[*].filter.ssn: String| \\
				& \verb|subscriptions[*].filter.city: String| \\
				& \verb|subscriptions[*].filter.province: String| \\
				& \verb|subscriptions[*].filter.country: String| \\
				& \verb|subscriptions[*].filter.gender: Gender| \\
				& \verb|subscriptions[*].filter.minAge: Integer| \\
				& \verb|subscriptions[*].filter.maxAge: Integer| \\
				& \verb|subscriptions[*].filter.bloodType: BloodType| \\
				& \verb|subscriptions[*].thirdParty: ThirdParty| \\
				& \verb|subscriptions[*].thirdParty.name: String| \\
				& \verb|subscriptions[*].thirdParty.certificate: String| \\
				& \verb|subscriptions[*].thirdParty.phone: String| \\
				& \verb|subscriptions[*].thirdParty.taxCode: String| \\				
				& \verb|subscriptions[*].timeSpan: Integer|  \\
			\end{tabular}\\
			
			\item{\verb|void removeSubscription(Spark.Request req, Spark.Response res)|\\ \verb|DELETE /web/subscriptions/:subscriptionId|} 			
		\end{itemize}
		
				\item{\textbf{SubscriptionResource}}
					\begin{itemize}
						\item{\verb|Collection<Subscription> getAllByIndividual(ObjectId individualId)|}
						\item{\verb|Collection<Subscription> getAllByOwner(ObjectId thirPartyId)|}
						\item{\verb|Subscription getByOwnerAndId(String thirdPartyId, String sid)|}
						\item{\verb|void removeByRequest(D4HRequest req)|}
					\end{itemize}
			\end{itemize}
			
			\item{\textbf{User}}
			\begin{itemize}
				\item{\textbf{UserService}}
					\begin{itemize}
			\item{\verb|D4HUserResponse getProfileInfo(Spark.Request req,|\\ \verb|Spark.Response res)|\\ \verb|GET /web/me/|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				& \verb|name: String| \\
				& \verb|ssn: String| \\
				& \verb|birthDate: Date| \\
				& \verb|gender: Gender| \\
				& \verb|bloodType: BloodType| \\
				& \verb|weight: Float| \\
				& \verb|height: Float| \\
				& \verb|address: Address| \\
				& \verb|address.country: String| \\
				& \verb|address.province: String| \\
				& \verb|address.city: String| \\
				& \verb|pendingRequests: Long| \\
				& \verb|approvedRequests: Long| \\
				& \verb|rejectedRequests: Long| \\
				\hline
				& \verb|name: String| \\
				& \verb|phone: String| \\
				& \verb|taxCode: String| \\
				& \verb|secretKey: String| \\
				& \verb|appId: String| \\
				& \verb|config: TPConfiguration| \\
				& \verb|config.individualPushUrl: String| \\
				& \verb|config.bulkPushUrl: String| \\
				& \verb|config.notificationUrl: String| \\
				& \verb|pendingRequests: Long| \\
				& \verb|approvedRequests: Long| \\
				& \verb|rejectedRequests: Long| \\
				
				\end{tabular}\\
				
		\item{\verb|TPConfiguration updateThirdPartyConfig(Spark.Request req,|\\ \verb|Spark.Response res)|\\ \verb|PATCH /web/me/config|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} \textit{[TPConfiguration]} & \textbf{Output} \\
			\hline
				\verb|config: TPConfiguration| & \verb|config: TPConfiguration| \\
				\verb|config.individualPushUrl: String|& \verb|config.individualPushUrl: String| \\
				\verb|config.bulkPushUrl: String|& \verb|config.bulkPushUrl: String| \\
				\verb|config.notificationUrl: String|& \verb|config.notificationUrl: String| \\
			\end{tabular}\\      			
		\end{itemize}
	\end{itemize}
\end{itemize}

\subsection{AutomatedSOS interfaces}
	ASOS has a different architecture as the ones seen in T4R and D4H, because it does not relay on a web-site nor a user. The system receives the data of the subscribed Individuals through the DataAPI, which is the interface provided to D4H, to which it connects. The NotificationAPI, let D4H connect to ASOS in order to send the status of the Requests sent to an Individual.  In the following list, the exposed interfaces are shown, linked with the classes and methods, and detailing the inputs and outputs:
	\begin{itemize}
		\item{\textbf{DataService}}
			\begin{itemize}
				\item{DataService}
					\begin{itemize}
						\item{\verb|void getIndividualData(Spark.Request req, Spark.Response res)|\\ \verb|POST /api/data|}\\\\
				\begin{tabular}{l | l}
				\textbf{Input} \textit{[IndividualDataRequest]} & \textbf{Output} \\
				\hline
					\verb|ssn: String| & \\
					\verb|data: Data| & \\
					\verb|data.location: Location| & \\
					\verb|data.location.longitude: Long| & \\
					\verb|data.location.latitude: Long| & \\
					\verb|data.healthStatus: HealtStatus| & \\
					\verb|data.healthStatus.heartRate: Integer| & \\
					\verb|data.healthStatus.systolic: Double| & \\
					\verb|data.healthStatus.diastolic: Double| & \\
					\verb|data.healthStatus.bodyTemperature: Integer| & \\
					\verb|data.healthStatus.bloodOxygen: Integer| & \\
				\end{tabular}\\
				\item{\verb|void getRequestNotification(Spark.Request req, Spark.Response res)|\\ \verb|POST /api/notification|}\\\\
				\begin{tabular}{l | l}
				\textbf{Input} \textit{[NotificationRequest]} & \textbf{Output} \\
				\hline
					\verb|individual: ASOSUser| & \\
					\verb|individual.ssn: String| & \\
					\verb|individual.birthDate: LocalDate| & \\
					\verb|individual.gender: Gender| & \\
					\verb|individual.bloodType: BloodType| & \\
					\verb|status: RequestStatus| & \\
				\end{tabular}\\
					\end{itemize}
					\item{ThresholdResource}
					\begin{itemize}
						\item{\verb|HashMap<HealthParameter, Threshold> get(Integer age)|}
						\item{\verb|Boolean isOutOfRange(Double value, Threshold threshold)|}
					\end{itemize}
					\item{UserResource}
					\begin{itemize}
						\item{\verb|ASOSUser getBySSN(String ssn)|}
						\item{\verb|void remove(String userId)|}
					\end{itemize}
			\end{itemize}
		\item{\textbf{APIManager}}
			\begin{itemize}
				\item{APIManager}
					\begin{itemize}
						\item{\verb|void sendNotification(EmergencyContact contact, ASOSUser user)|}
					\end{itemize}
			\end{itemize}
		\item{\textbf{DBManager}}
			\begin{itemize}
				\item{DBManager}
					\begin{itemize}
						\item{\verb|Morphia.Datastore getDatastore()|}
					\end{itemize}
			\end{itemize}
	\end{itemize}	
	
	\subsection{Track4Run interfaces}
	The following is a list of all the components of T4R, and the classes that belong to them, with the exposed methods. \\
	
		As in D4H, the Service classes have methods that are related to the endpoints used by the web-site. A special case is the DataHandler component, which is responsible of getting the notifications from D4H and the data of the individuals. The  NotificationAPI and DataAPI refer to the interfaces exposed to D4H and to which it connects. On the other hand, the Request component connects to D4H by using the RequestAPI, in order to send Requests for accessing individual location during an event. In the following list, the exposed interfaces - used by the web-site and by D4H - are shown, linked with the classes and methods, and detailing the inputs and outputs:

	\begin{itemize}
		\item{\textbf{Login}}
			\begin{itemize}
				\item{\textbf{LoginService}}
					\begin{itemize}
						\item{\verb|LoginResponse login(Spark.Request req, Spark.Response response)|\\ \verb|POST /web/login|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
			\verb|email: String| & \verb|userId: String| \\
			\verb|password: String| & \verb|accessToken: String| \\
			& \verb|type: UserType| 
			\end{tabular}\\
			\item{\verb|void logout(Spark.Request req, Spark.Response response)|\\ \verb|POST /web/logout|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
			\verb|userId: String| & \\
			\verb|accessToken: String| & \\
			\end{tabular}\\
					\end{itemize}
					
				\item{\textbf{UserResource}}
					\begin{itemize}
						\item{\verb|T4RUser getByEmailAndPass(String email, String password)|}
					\end{itemize}
			\end{itemize}
			
		\item{\textbf{Signup}}
			\begin{itemize}
				\item{\textbf{SignupService}}
					\begin{itemize}
						\item{\verb|SignupResponse signupParticipant(Spark.Request req, Spark.Response res)|\\ \verb|POST /web/individual/signup|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				\verb|email: String| & \verb|userId: String| \\
				\verb|password: String| & \verb|accessToken: String| \\
				\verb|name: String| & \\
				\verb|ssn: String| & \\
			\end{tabular}\\
			\item{\verb|SignupResponse signupOrganizer(Spark.Request req, Spark.Response res)|\\ \verb|POST /web/thirdparty/signup|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				\verb|email: String| & \verb|userId: String| \\
				\verb|password: String| & \verb|accessToken: String| \\
				\verb|name: String| & \\
				\verb|phone: String| & \\
				\verb|website: String| & \\
			\end{tabular}\\
					\end{itemize}
					
				\item{\textbf{UserResource}}
					\begin{itemize}
						\item{\verb|void add(T4RUser u)|}
					\end{itemize}
			\end{itemize}
			
		\item{\textbf{User}}
			\begin{itemize}
				\item{\textbf{UserService}}
					\begin{itemize}
						\item{\verb|Collection<Participant> getEnrolledParticipants(Spark.Request req, |\\ \verb|Spark.Response res)|\\ \verb|GET /web/:eventId/participants|}\\\\
				\begin{tabular}{l | l}
				\textbf{Input} & \textbf{Output} \\
				\hline
					& \verb|participants: Collection<Participant>| \\
					& \verb|participants[*].userId: String| \\
					& \verb|participants[*].name: String| \\
				\end{tabular}\\
				\item{\verb|void enrollToEvent(Spark.Request req, Spark.Response res)|\\ \verb|POST /web/participant/:userId/:eventId|}
				\item{\verb|void cancelEnrollment(Spark.Request req, Spark.Response res)|\\ \verb|DELETE /web/participant/:userId/:eventId|}
			\end{itemize}
		\end{itemize}
			
		\item{\textbf{Event}}
			\begin{itemize}
				\item{\textbf{EventService}}
					\begin{itemize}
						\item{\verb|Collection<Event> getAvailableEvents(Spark.Request req, Spark.Response res)|\\ \verb|GET /web/event|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				& \verb|events: Collection<Event>| \\
				& \verb|events[*].eventId: String| \\
				& \verb|events[*].name: String| \\
				& \verb|events[*].startDate: Date| \\
				& \verb|events[*].organizer: Organizer| \\
				& \verb|events[*].organizer.name: String| \\
			\end{tabular}\\
			\item{\verb|void createEvent(Spark.Request req, Spark.Response res)|\\ \verb|POST /web/event|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				\verb|name: String| & \\
				\verb|organizerId: String| & \\
				\verb|startDate: Date| & \\
				\verb|endtDate: Date| & \\
				\verb|path: Collection<Coordinate>| & \\
				\verb|path[*].longitude: Long| & \\
				\verb|path[*].latitude: Long| & \\
			\end{tabular}\\
			\item{\verb|void updateEvent(Spark.Request req, Spark.Response res)|\\ \verb|PUT /web/event/:eventId|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				\verb|name: String| & \\
				\verb|startDate: Date| & \\
				\verb|endtDate: Date| & \\
				\verb|path: Collection<Coordinate>| & \\
				\verb|path[*].longitude: Long| & \\
				\verb|path[*].latitude: Long| & \\
			\end{tabular}\\
					\end{itemize}
					
				\item{\textbf{EventResource}}
					\begin{itemize}
						\item{\verb|Event getById(String eventId)|}
						\item{\verb|Collection<Event> getAll()|}
						\item{\verb|void add(Event e)|}
						\item{\verb|void update(Event e)|}
					\end{itemize}
			\end{itemize}
			
		\item{\textbf{Notification}}
			\begin{itemize}
				\item{\textbf{NotificationService}}
					\begin{itemize}
						\item{\verb|Collection<Notification> getPendingNotifications(Spark.Request req,|\\ \verb|Spark.Response res)|\\ \verb|GET /web/:userId/notification|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				& \verb|notifications: Collection<Notification>| \\
				& \verb|notifications[*].event: Event| \\
				& \verb|notifications[*].event.eventId: String| \\
				& \verb|notifications[*].event.name: String| \\
			\end{tabular}\\
			\item{\verb|void accept(Spark.Request req, Spark.Response res)|\\ \verb|PUT /web/:userId/notification/:notificationId|}
			\item{\verb|void delete(Spark.Request req, Spark.Response res)|\\ \verb|DELETE /web/:userId/notification/:notificationId|}
			\item{\verb|void createNotification(Spark.Request req, Spark.Response res)|\\ \verb|POST /web/notification|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				\verb|userId: String| & \\
				\verb|eventId: String| & \\
			\end{tabular}\\
					\end{itemize}
					
				\item{\textbf{NotificationResource}}
					\begin{itemize}
						\item{\verb|Notification getByUserId(String userId)|}
						\item{\verb|void update(Notification u)|}
					\end{itemize}
					
				\item{\textbf{EventResource}}
					\begin{itemize}
						\item{\verb|Event getById(String eventId)|}
						\item{\verb|void addParticipant(String eventId, String participantId)|}
					\end{itemize}
			\end{itemize}
			
		\item{\textbf{DataHandler}}
			\begin{itemize}
				\item{\textbf{DataHandler}}
					\begin{itemize}
						\item{\verb|void getParticipantLocation(Spark.Request req, Spark.Response res)|\\ \verb|POST /api/participant/data|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				\verb|ssn: String| & \\
				\verb|data: Data| & \\
				\verb|data.location: Location| & \\
				\verb|data.location.longitude: Long| & \\
				\verb|data.location.latitude: Long| & \\
				\verb|data.healthStatus: HealtStatus| & \\
				\verb|data.healthStatus.heartRate: Integer| & \\
				\verb|data.healthStatus.bloodPreasure: Integer| & \\
				\verb|data.healthStatus.bodyTemperature: Integer| & \\
				\verb|data.healthStatus.bloodOxygen: Integer| & \\
			\end{tabular}\\
			\item{\verb|void getRequestNotification(Spark.Request req, Spark.Response res)|\\ \verb|POST /api/participant/notification|}\\\\
			\begin{tabular}{l | l}
			\textbf{Input} & \textbf{Output} \\
			\hline
				\verb|name: String| & \\
				\verb|ssn: String| & \\
				\verb|birthDate: Date| & \\
				\verb|gender: Gender| & \\
				\verb|status: RequestStatus| & \\
			\end{tabular}\\
					\end{itemize}
		\end{itemize}
			
		\item{\textbf{Request}}
			\begin{itemize}
				\item{\textbf{RequestService}}
					\begin{itemize}
						\item{\verb|void sendRequestToParticipant(String ssn)|}
					\end{itemize}
			\end{itemize}
	\end{itemize}		
	
	\section{Database view}
In the previous section, an architectural landscape of D4H, ASOS and T4R was provided by means of high-level component diagrams. Those diagrams showed how components communicate with the rest of the system (i.e. through interfaces). Now, it is also meaningful to describe data models involved using class diagrams. 
	
	\subsection{Data4Help data model}
	As explained in the RASD, the whole data model of TrackMe up to now will be treated as a "black box", this means \textbf{D4H} will have a local copy of the \textit{basic information} and \textit{collected data} only of users who activated this service. The classes considered in D4H, their attributes, and relationships are shown in Figure \ref{fig:d4h_class_diagram}.
	
	\begin{itemize}
		\item{\textbf{D4HUser}}: credentials of all users interacting with the system.
		\item{\textbf{Individual}}: main attributes of users wearing the devices.
		\item{\textbf{Data}}: health status, location and timestamp collected from devices.
		\item{\textbf{ThirdParty}}: companies requesting data of individuals or bulk data. For registering, all third parties must provide a certificate to verify that it is a legally constituted company (it was assumed that there is a mechanism capable of doing this checking).		
		\item{\textbf{TPConfiguration}}: an important issue to tackle is the way in which the system will communicate to third parties to send them notifications or data they request. Then, they are asked to provide three endpoints,
	 \textit{individualpushUrl}, \textit{bulkPushUrl} and \textit{notificationUrl}.	 
		\item{\textbf{D4HRequest}}: third parties can make requests to access data of a given individual. Each request has an associated \textit{status}, initially is \textit{PENDING} and can become either \textit{APPROVED} or \textit{REJECTED} according to whether the individual accepts it or not. 
		\begin{itemize}
		\item After the status of a request is updated to \textit{APPROVED}, a subscription to receive new data of the intended individual is automatically created. 
		\item \textit{Requests for bulk data} are treated differently. The only constraints are managed by the system (if they do not hold the third party is notified), then there is no need to store them.
		\end{itemize}
		\item{\textbf{Subscription}}: when searching for bulk data, third parties can decide if they want to subscribe to that specific \textit{filter}. This means, they will receive new data after a certain amount of time defined by a \textit{timeSpan} (hours). New data will be send to individuals according to the nextExecution attribute of the subscription.
	\end{itemize}

	\begin{figure}[H]
    		\centering
		\includegraphics[width=1.1\textwidth]{diagrams/d4h_class_diagram.png}
		\caption[Data4Help Class Diagram]{Data4Help Class Diagram}
		\label{fig:Data4Help Class Diagram}
	\end{figure}
	
	\subsection{AutomatedSOS data model}
	 The classes considered in D4H, their attributes, and relationships are shown in Figure \ref{fig:Data4Help Class Diagram}.
	 
	\begin{itemize}
		\item{\textbf{ASOSUser}}: individuals subscribed to D4H that decided to activate ASOS service. Each individual is associated atutomatically to the \textbf{EmergencyContact} corresponding to his address. They also have a \textit{status} so as to avoid duplicate notifications to the health care service. 
		\item{\textbf{EmergencyContact}}: available health care services by addresses.  Each health care service will receive notifications by means of a URL and only of users living in the same city.
		\item {\textbf{Data}}: health parameters measured by means of the wearable devices and received from D4H.
		\item {\textbf{Threshold}}: normal ranges for each health parameter according to the age of the individual (i.e. minimum and maximum values).
	\end{itemize}
	
	Data coming from d4h is compared against predefined thresholds, all of them are described as follows (Figure \ref{fig:health_parameters_thresholds}): \\
	
	\begin{table}[h]
		\centering
		\begin{tabular}{c | c | c | c | c}
			\hline \hline
			\textbf{HealthParameter} & \textbf{minAge}  & \textbf{maxAge} & \textbf{minValue} & \textbf{maxValue}  \\ [0.5ex]
			\hline
				HEART\_RATE  & 60 & 65 & 80 & 120  \\
				HEART\_RATE  & 65 & 70  & 78 & 116 \\
				HEART\_RATE  & 70 & 75 & 75  & 113  \\
				HEART\_RATE  & 75 & 130 & 73 & 109 \\
				SYSTOLIC   & 0 & 130 & 90 & 250  \\
				DIASTOLIC & 0 & 130 & 60 & 140   \\
				TEMPERATURE  & 60 & 65 & 35.2 & 36.9 \\
				TEMPERATURE & 65 & 130 & 35.6 & 36.3 \\
				BLOOD\_OXYGEN   & 0 & 130 & 97 & 100    
		\end{tabular}
		\caption{Thresholds for every health parameter}
		\label{fig:health_parameters_thresholds}
	\end{table}
	
		It is necessary to clarify that the parameters (i.e. users' data) are not stored, they are used exclusively to make comparisons with their corresponding  \textit{thresholds}. \\
	
	
	\begin{figure}[H]
    		\centering
		\includegraphics[width=1.1\textwidth]{diagrams/asos_class_diagram.png}
		\caption[AutomatedSOS Class Diagram]{AutomatedSOS Class Diagram}
		\label{fig:AutomatedSOS Class Diagram}
	\end{figure}
	
	\subsection{Track4Run data model}
	\begin{itemize}
		\item{\textbf{Run}}:  characterized by a name, start and end times, and a path.
		\item{\textbf{Organizer}}: responsible for setting it up runs and send invitations to individuals.
		\item {\textbf{Participant}}: individuals enrolled in any run.
		\item {\textbf{Invitation}}: invitations to participate on runs sent by organizers.
	\end{itemize}
	
	The system does not need to keep record of the spectators. \\
	
	\begin{figure}[H]
    		\centering
		\includegraphics[width=0.9\textwidth]{diagrams/t4r_class_diagram.png}
		\caption[Track4Run Class Diagram]{Track4Run Class Diagram}
		\label{fig:Track4Run Class Diagram}
	\end{figure}	
			
	\section{Deployment view}
	In the current chapter the deployment diagrams of D4H, T4R and ASOS are shown. All diagrams follow the same structure and design: yellow nodes represent external nodes that interact with the system, green nodes represent hardware devices (i.e. web server, database server, etc.), pale orange nodes represent execution environments such as JVM, and blue boxes represent high level components. Finally, the protocols used to communicate between different nodes displayed as red links.
	
	\subsection{Data4Help deployment diagram}
	In the Figure \ref{fig:d4h_deployment_diagram} can be seen the deployment diagram of D4H. As can be seen, the \textbf{Web Server} node, is a device which contains the execution environment that holds the \textbf{D4H Backend} component. The \textbf{Web Server} node, is related to two different devices: a \textbf{MongoDB Server} which is the environment of the \textbf{TrackMe DB}, and a \textbf{Redis Server} which is the environment of the \textbf{TokenDB}.\\
	
	Moreover, the \textbf{Web Server} is related to three third parties: two of them are \textbf{Track4Run} execution environment, and \textbf{AutomatedSOS} execution environment. The third third party is a \textbf{Generic Third Party Backend} node that is external to the TrackMe environment.\\
	
	It worth notice, that the \textbf{Smart devices} are the ones that provide the data of the individuals to D4H. These devices connect to the D4H back-end using the internal interface, as shown in Figure \ref{fig:d4h_component_diagram}.\\
	
	Finally, the deployment diagram does not show the interaction between the web-users (individuals or third parties) with the system. This interaction is inherent to a web site, and it happens between the client and the \textbf{D4H Web page} component.
	
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\textwidth]{diagrams/d4h_deployment_diagram.png}
			\caption[Data4Help Deployment Diagram]{Data4Help Deployment Diagram}
			\label{fig:d4h_deployment_diagram}
		\end{figure}	
	
	\subsection{AutomatedSOS deployment diagram}
	In the Figure \ref{fig:asos_deployment_diagram} the ASOS deployment diagram is shown. Since ASOS does not have a web site, the main node is an \textbf{Application Server} that hosts the execution environment for the \textbf{ASOS Backend} component. The \textbf{Application Server} interacts with a \textbf{MongoDB Server} node, using the TCP/IP protocol. Moreover, it interacts with an external node which represent the different \textbf{Health Care Service}s, and with the execution environment of \textbf{Data4Help}.
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.9\textwidth]{diagrams/asos_deployment_diagram.png}
			\caption[AutomatedSOS Deployment Diagram]{AutomatedSOS Deployment Diagram}
			\label{fig:asos_deployment_diagram}
		\end{figure}	
	
	\subsection{Track4Run deployment diagram}
	In the Figure \ref{fig:t4r_deployment_diagram} the T4R deployment diagram is shown. It can be seen the interaction between \textbf{Data4Help} execution environment and the \textbf{Web Server} node. This interaction happens thanks to the different interfaces provided by D4H and T4R. \\
	Furthermore, the \textbf{Web Server} node interacts with the \textbf{MongoDB Server} node using the TCP/IP protocol, and it works thanks to the \textbf{DBConnector} interface provided by the \textbf{T4R Database} component. \\
	
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\textwidth]{diagrams/t4r_deployment_diagram.png}
			\caption[Track4Run Deployment Diagram]{Track4Run Deployment Diagram}
			\label{fig:t4r_deployment_diagram}
		\end{figure}
		
	\section{Runtime view}
	In the following section sequence diagrams of D4H, T4R and ASOS are shown. 
	
	\subsection{Data4Help sequence diagrams}
	In D4H the \textbf{:SignupService} component receives a signup request, and 
	communicates with the \textbf{:UserWebAuth} in charge of creating an accessToken and userId for the session of the user, they are send back to the \textbf{GUI}. This process applies for third parties as well, by means of \textbf{signupThirdParty} exposed method. 
	
	\begin{itemize}
	\item \textbf{Registration} 
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/d4h_signup.png}
		\caption[Signup Sequence Diagram]{Signup Sequence Diagram}
		\label{fig:d4h_seq_signup}
	\end{figure}
	
	\item \textbf{Login} \\
	The system also provides login and logout mechanisms to both types of users: individuals and third parties. The \textbf{:LoginService} component is in charge of contacting the \textbf{:AuthenticationManager} to set the accessToken for the user. This token is retrieved to the \textbf{GUI} to be used for upcoming requests. The GUI decides whether to redirect the user to its corresponding dashboard or display an error according to credentials checking. \\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/d4h_login_logout.png}
		\caption[Login and Logout Sequence Diagram]{Login and Logout Sequence Diagram}
		\label{fig:d4h_seq_login_logout}
	\end{figure}
	
	\item \textbf{Get All Requests} \\
	After login into the system, any individual can check all requests he received from third parties. The \textbf{:D4HRequestService} component is the responsible for this process.  It gets the requests by means of the \textbf{:RequestResource} and returns them to the \textbf{GUI} (Figure \ref{fig:d4h_seq_show_requests}). \\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/d4h_show_requests.png}
		\caption[Show Requests Sequence Diagram]{Show Requests Sequence Diagram}
		\label{fig:d4h_seq_show_requests}
	\end{figure}
	
	\item \textbf{Manage Requests} \\
	The \textbf{:RequestService} component provides to each individual a way to manage his own requests (i.e. accept or reject them). In both cases the status of the request is updated to \textit{APPROVED} or \textit{REJECTED} respectively. If the request was accepted, the component creates a subscription allowing the third party associated to the request to receive new data. Otherwise, the request is deleted. In both cases, the third party who created the request will be notified (Figure \ref{fig:d4h_seq_ notify_third_party}). \\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1.1\textwidth]{diagrams/sequence_diagrams/d4h_manage_requests.png}
		\caption[Manage Requests Sequence Diagram]{Manage Requests Sequence Diagram}
		\label{fig:d4h_seq_manage_requests}
	\end{figure}

	\item \textbf{Notify Third Party} \\
	Notifications to third parties are handled by the \textbf{:APIManager} component. In detail, \textbf{:D4HRequestService} asks :APIManager to send a notification to a given third party, to do so this component asks to the :\textbf{DBManager} the \textit{APIConfiguration} (of the third party) that contains the URL to which the message will be posted. \\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\textwidth]{diagrams/sequence_diagrams/d4h_notify_third_party.png}
		\caption[Notify Third Party Sequence Diagram]{Notify Third Party Sequence Diagram}
		\label{fig:d4h_seq_ notify_third_party}
	\end{figure}
	
	\item \textbf{Send Request} \\
	As concerns to third parties, they can send requests (Figure \ref{fig:d4h_seq_send_request}) to individuals in order to have future access to their data. All this process is handled by  \\ \textbf{:D4HRequestService} component.  \\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\textwidth]{diagrams/sequence_diagrams/d4h_send_request.png}
		\caption[Data4Help Send Request Sequence Diagram]{Data4Help Send Request Sequence Diagram}
		\label{fig:d4h_seq_send_request}
	\end{figure}
	
	\item \textbf{Search for individual or bulk data} \\
	Third parties can search for data of a specific individual or bulk data. If a third parties has approved requests to data of any individual, he can search for that data using the ssn of the individual. This operation is carried out by the \textbf{:SearchService}, which provides to the \textbf{GUI} information concerning the request. \\
	
	If third parties want to search for bulk data, they have several available filtering criteria. All those filters are received by the \textbf{:SearchService}, which returns to the \textbf{GUI} the data anonymized (Figure \ref{fig:d4h_access_data}) .\\ 
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/d4h_subscribe_to_data.png}
		\caption[Data4Help Access Data Sequence Diagram]{Data4Help Access Data Sequence Diagram}
		\label{fig:d4h_access_data}
	\end{figure}
	
	\item \textbf{Subscribe to data}\\
	Third parties can subscribe to a specific search, this way he will get new data according to the the \textit{time span} specified by the third party (Figure \ref{fig:d4h_subscribe_to_data}).
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/d4h_subscribe_to_data.png}
		\caption[Data4Help Subscription Sequence Diagram]{Data4Help Subscription Sequence Diagram}
		\label{fig:d4h_subscribe_to_data}
	\end{figure}
	
	\subsection{AutomatedSOS sequence diagrams}
	Since ASOS is an event-based service, it does not provide a GUI. That is why the main "actor" is Data4Help, which is the boundary of a different service. In the Figure \ref{fig:asos_seq_get_notification} the \textit{Get Request Notification} use case is shown. As mentioned before, the component that initiates the process is Data4Help, which sends a message every time an Individual accepts or rejects the ASOS request. If the individual has accepted the request, the \textbf{:DataService} component will update the information of the Individual in the database, and will assign an emergency contact based on its Address.\\
	
	On the other hand, if the individual has rejected the request, :DataService component will remove it from the database.\\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/asos_get_individual_notification.png}
		\caption[AutomatedSOS get notification sequence diagram]{AutomatedSOS get notification sequence diagram}
		\label{fig:asos_seq_get_notification}
	\end{figure}
	
	Finally, the core functionality of ASOS is shown in the Figure \ref{fig:asos_seq_receive_data}. It can be seen that, as before, the "actor" that initiates the process is Data4Help service, which sends the Individual health data. This message is handled by \textbf{:DataService} component, which will compare the information with the previously defined thresholds. If the Data is out of range, the :DataService will send a message to the \textbf{:APIManager} component in order notify the emergency contact assigned for the Individual. The :APIManager component is responsible of getting the assigned emergency contact information, and notifies the \textbf{EmergencyService}.\\
	
	It worth mentioning that the notification to the health-care service is done asynchronously. On the other hand, if the data is \textit{\textbf{not}} out of range, the system will do nothing.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/asos_receive_individual_data_and_notify_emergency_service.png}
		\caption[AutomatedSOS receive data and notify emergency service sequence diagram]{AutomatedSOS receive data and notify emergency service sequence diagram}
		\label{fig:asos_seq_receive_data}
	\end{figure}
	
	\subsection{Track4Run sequence diagrams}
	In the Figure \ref{fig:t4r_seq_signup} the signup process is shown. It can be seen the \textbf{:Signup} component, which is responsible of getting the participant's information, and with the help of the\textbf{:DBManager} component, save it into the database. \\ The \textbf{:AuthenticationManager} component is responsible of create the access token for the session. Finally, the :Signup component sends a message to the \textbf{:Request} component which, asynchronously,  sends a request for accessing the individual's information to D4H. The process ends when the \textbf{GUI} redirects the new user to its dashboard.\\
	
	It worth mentioning, that the organizer signup process is similar to the signup process of the Participant. The only difference is that, in the case of the Organizer, the \textbf{:Signup} component does not send a message to the \textbf{:Request }component.\\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/t4r_signup_participant.png}
		\caption[Track4Run Signup sequence diagram]{Track4Run Signup sequence diagram}
		\label{fig:t4r_seq_signup}
	\end{figure}
	
	In the Figure \ref{fig:t4r_seq_login} the login and logout processes are shown. It can be noticed that the actor is either a participant or an organizer, since the process is the same for both of them. If there exist a user that has an email and password as the one sent to the \textbf{:Login} component, then it should ask the \textbf{:AuthenticationManager} component to create an access token for that user. If the credentials are right, the \textbf{GUI} will redirect the user to its dashboard. Otherwise, it will show an error.\\
	
	In the case of logout, the GUI should send the access token and the userId to the \textbf{: Login} component, which will send a message to the \textbf{:AuthenticationManager} component in order to validate it. If it is valid, it will remove the access token in order to remove the session, and the \textbf{GUI} will redirect the user to the home page.\\ 
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/t4r_login_logout.png}
		\caption[Track4Run Login/logout sequence diagram]{Track4Run Login/logout sequence diagram}
		\label{fig:t4r_seq_login}
	\end{figure}
	
	In the Figure \ref{fig:t4r_seq_create_run} the create a run process is shown. This process involves the organizer, who should send the startDate, endDate and name for the event. These parameters will be handled by the \textbf{:Event} component, which will save the new event in the database with the help of \textbf{:DBManager} component. Moreover, the organizer can add the coordinates for the running circuit by updating the previously create event. After this step, the \textbf{GUI} will show the possible participants to invite, and the organizer can skip this, or choose and send the invitations to selected participants. In that case, and after choosing which participants will receive an invite, the GUI will send a message to the \textbf{:Notification} component, which will add the notifications into the database. This final process is asynchronous.\\
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/t4r_create_run.png}
		\caption[Track4Run create run sequence diagram]{Track4Run create run sequence diagram}
		\label{fig:t4r_seq_create_run}
	\end{figure}
	
	Finally, in the Figure \ref{fig:t4r_seq_accept_invitation}, the accept and reject invitation processes are shown. First, the participant will ask the \textbf{GUI} for all the pending notifications, and it will ask to the \textbf{:Notification} component for the notifications of the user. If a user decides to accept a notification, the GUI will send a message to the \textbf{:Event} component, which will add the participant to the :Event.\\

	 On the other hand, if the participant decides to reject the invitation, the GUI will send a message to the :Notification component in order to delete it.\\
	 
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{diagrams/sequence_diagrams/t4r_accept_reject_notification.png}
		\caption[Track4Run accept/reject invitation sequence diagram]{Track4Run accept/reject invitation sequence diagram}
		\label{fig:t4r_seq_accept_invitation}
	\end{figure}	
	
	\end{itemize}
	
	\section{Selected architectural styles and patterns}
Resuming the high level architecture of the system briefly explained on \textit{ \autoref{sec:overview} Overview}, it is important to describe MVC	and event-driven design patterns, how they work and why are the proper ones to build up each subsystem.

	\subsection{Model View Controller architecture (MVC)}
	The Model View Controller (commonly known as MVC) design pattern helps  to build applications that are easier to test and maintain, is the way of structuring server side code 
	It comprises of three major components:
	
	\begin{itemize}
	\item {\textbf{Model}}: this is the layer that represents the application's data and define the logic for manipulating that data.
	\item {\textbf{View}}: this represents the presentation or the user interface layer, something visible in the user interface.
	\item{\textbf{Controller}}: this layer typically contains the business logic of your application, and acts as a mediator between model and view components.
	\end{itemize}

	In other words, the \textit{model} is the part of the application that is responsible for the logic needed for the treatment of data. Normally model objects retrieve data (and store data) from a database. The \textit{view} is the parts of the application that is responsible for the visualization of the data. Usually views are created from the model data. The \textit{controller} is the part of the application that is in charge of the interaction with the user. Normally, drivers read data from a view. \\
	
	MVC design pattern is perfect for D4H and T4R systems because it is based on \textit{separation of concerns}, this makes the application's code easier to test and maintain. In a typical MVC design, the request first arrives at the controller which binds the model with the corresponding view. This separation helps manage complex applications, because the developer can focus on one aspect at a time and also simplifies the development of group applications, different developers can work in parallel. 
 
	\subsubsection{RESTful web services}
	The communication between D4H/T4R with their users is done via HTTP requests following REST principles. REST (Representation State Transfer) is an architectural style for communication based on strict use of HTTP request types (Figure\ref{fig:RESTful web services}) .\\
	
	\begin{figure}[H]
    		\centering
		\includegraphics[width=1\textwidth]{diagrams/mvc.png}
		\caption[RESTful web services]{RESTful web services}
		\label{fig:RESTful web services}
	\end{figure}
	 
	One of the most important REST principles is that the interaction between the client and server is stateless between requests. Each request from the client to the server must contain all of the information necessary to understand the request. The client wouldn't notice if the server were to be restarted at any point between the requests.\\
	
	On the server side, the application state and functionality are divided into resources. A resource is an item of interest, a conceptual identity that is exposed to the clients. Example resources include application objects, database records, algorithms, and so on. Every resource is uniquely addressable using a URI (Universal Resource Identifier). All resources share a uniform interface for the transfer of state between client and server. Standard HTTP methods such as GET, POST, PUT, and DELETE are used. \\
	
	The RESTful HTTP requests are categorized according to method types as the following:
	\begin{itemize}
	\item {\textbf{GET}}: used to retrieve resource representation/information only – and not to modify it in any way. 
	\item {\textbf{POST}}: used to create a new resource into the collection of resources.
	\item {\textbf{PUT}}: used primarily to update existing resource (if the resource does not exist then API may decide to create a new resource or not).
	\item {\textbf{DELETE}}: used to delete resources (identified by the Request-URI).
	\end{itemize}
	
	\subsection{Event-driven architecture (EDA)}
	The event-driven is a popular distributed asynchronous architecture, made up of highly decoupled, single-purpose event processing components that asynchronously receive and process events. Basically, a system sends event messages to notify other systems of a change in its domain and it does not really care much about the response. EDA are useful to simplify data management, so as to tackle real-time processing with minimum time lag (high volume and high velocity of data). 
	
	\begin{figure}[H]
    		\centering
		\includegraphics[width=0.9\textwidth]{diagrams/event_driven.png}
		\caption[Event driven architecture]{Event driven architecture}
		\label{fig:Event driven architecture}
	\end{figure}

	For ASOS, a simple event processing will be implemented, this means that an event immediately triggers an action in the consumer. This is, after receiving  Individuals' data, and based on the defined thresholds it decides whether to notify or not their associated health care services. 
	
	\section{Other design decisions}
	In the following section a list of suggested development frameworks and technologies	are listed. The 3 systems, are designed to be highly decoupled so it is not necessary to develop them with the same technologies, even though it is recommended. Further details will be given in future documents.\\
	
	To begin with, it is suggested to build Java based applications, since developers have expertise working with this language. Moreover, it is proposed to use \textbf{Java Spark Framework}, which is a micro-framework for MVC applications, because pure Java web development has traditionally been very cumbersome. The configuration for this framework is minimal and with a short learning curve. \\
	
	Furthermore, for database management a suggestion is to use \textbf{Morphia} which is a highly active project to connect with MongoDB. Also, it is simple, straightforward to use, it supports type conversion and uses MongoDB aggregation framework. While for the Redis database, it is recommended to use \textbf{Lettuce}, which is a fully non-blocking Redis client, that provides reactive, asynchronous and synchronous data access. It has also, a highly active community and a very well written documentation.\\
	
	Besides, for the front-end development, it is suggested to use the last release of \textbf{Angular} (version 7.x), which is a very well known and widely used framework developed by Google. It is suggested to use Google Maps platform for displaying the running circuit and the participants in the T4R web-site.\\
	
	Finally, the only external APIs to whom TrackMe environment depends on, are the health-care services to which ASOS should contact in some cases. Both D4H and T4R do not depend on any external services.
	
	\chapter{User interface design}
	The user interfaces were introduced in the RASD, however in this section they
are examined in depth. \\ 
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.8]{UI/home.png}
		\caption[UI: TrackMe's Home Page]{TrackMe's Home Page}
		\label{fig:Home_Page}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.3]{UI/d4h.png}

		\caption[UI: Data4Help Information Page]{Data4Help Information Page}
		\label{fig:Data4Help Information Page}
	\end{figure}
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.3]{UI/asos.png}

		\caption[UI: ASOS Information Page]{ASOS Information Page}
		\label{fig:ASOS Information Page}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.8\textwidth]{UI/t4r.png}
		\caption[UI: Track4Run Web Page]{Track4Run Web Page}
		\label{fig:Track4Run Web Page}
	\end{figure}
	
	In the Figure \ref{fig:Track4Run Web Page}, Spectators are able to visualize all the available runs in which are currently going on; and by clicking on 'view participants' button, they are redirected to the map-view of the selected run, where they can view the live location of the participant users.	
	
	In the Figure \ref{fig:Login}, can be seen the web page through which users can Login into the system (if already registered).
	
	\begin{figure}[H]
		\centering
		\includegraphics[scale=0.25]{UI/9.jpeg}
		\caption[UI: Login Page]{Login Page}
		\label{fig:Login}
	\end{figure}
	
	 And if not already registered into the system, they can register themselves through the Register web-page (Figure \ref{fig:Registration}). There are separate register forms for the Individual users and for Third Party users.
	 \begin{figure}[H]
		\centering
		\includegraphics[scale=0.45]{UI/10.jpeg}
		\caption[UI: Registration Page]{Registration Page}
		\label{fig:Registration}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{UI/2.jpeg}
		\caption[UI: Individual Dashboard Page]{Individual Dashboard Page}
		\label{fig:Dashboard for individuals}
	\end{figure}

The above Figure \ref{fig:Dashboard for individuals} displays the dashboard for individual users, this page is responsive and a real-time view of the application for the individual user's point of view. Here, the user can seen his/her pending requests, accepted requests, and a list of all the requests he/she approved or rejected.

	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{UI/4.jpeg}
		\caption[UI: Manage Requests Page]{Manage Requests Page}
		\label{fig:manage_requests}
	\end{figure}

In the Figure \ref{fig:manage_requests} the individual user have options to accept or reject any request for data acquisition. As soon as an action is taken upon the request, it gets deleted from the page.

	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{UI/5.jpeg}
		\caption[UI: Third party Dashboard Page 1]{Third party Dashboard Page 1}
		\label{fig:third_party_dashboard_1}
	\end{figure}
	
	The above Figure \ref{fig:third_party_dashboard_1}, displays the dashboard for third party users, this page is responsive and a real-time view of the application for the third party user's point of view. Third parties can search for  data using the filtering criteria provided by the system such as country, province, city, age, blood type, or SSN.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{UI/6.jpeg}
		\caption[UI: Third party Dashboard Page 2]{Third party Dashboard Page 2}
		\label{fig:third_party_dashboard_2}
	\end{figure}
	
	The above figure \ref{fig:third_party_dashboard_2}, states that, if they click on the 'Check' sign then the request is sent to the individual which has the same SSN entered by the third party.
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{UI/1.jpeg}
		\caption[UI: Third party Dashboard Bulk Request Page]{Third party Dashboard Bulk Request Page}
		\label{fig:third_party_Bulk_Request_Page}
	\end{figure}
	
	The above figure \ref{fig:third_party_Bulk_Request_Page}, user s able to select the filter criterias according the which user wishes to get the data. Filter criterias are such as gender, age, demographic findings or the date of subscription. User is able to get filtered data, if already there (from previous requests).
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{UI/3.jpeg}
		\caption[UI: Individual Profile page]{Individual Profile page}
		\label{fig:user_profile_individual}
	\end{figure}
	
	The above figure \ref{fig:user_profile_individual}, user is able to view the details of his profile. This profile data is personal to every user. They can only access their own data; details include: ssn, name, address, blood type etc.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{UI/8.jpeg}
		\caption[UI: Third party Profile page]{Third party Profile page}
		\label{fig:user_profile_thirdparty}
	\end{figure}
	
	The above figure \ref{fig:user_profile_thirdparty}, user is able to view the details of his profile. This profile data is personal to every user. They can only access their own data; details include: tac code, contact and the configuration details (such as App id, secret key, bulk data and individual data URLs etc.
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{UI/db_organizer1.png}
		\caption[UI: Organizers' Dashboard Page]{Organizers' Dashboard Page}
		\label{fig:organizer_dashboard_1}
	\end{figure}
	In the Figure \ref{fig:organizer_dashboard_1}, the organizer can see the number of pending invites for the already configured runs which are still pending to send to the targeted participants; also, organizer's are able to view the number of already configured runs from the past; In addition, they can start configuring a new run by clicking on 'Create new run' button.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{UI/db_organizer2.png}
		\caption[UI: Organizers' Dashboard Page]{Organizers' Dashboard Page}
		\label{fig:organizer_dashboard_2}
	\end{figure}
	In the Figure \ref{fig:organizer_dashboard_2}, Organizer's are able to define the parameters to define a complete running circuit such as: start and end time, name of the run, date of the run, nodes of the running circuit and here they can select whether to send invitations now or not by clicking the check-box; Thus, by clicking on 'Complete running circuit' button, the configuration gets completed and based on the details above, run is configured.
	
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{UI/spectators_map.png}
		\caption[UI: Spectators' Map-view Page]{Spectators' Map-view Page}
		\label{fig:Spectators' Map-view Page}
	\end{figure}
	
	In the Figure \ref{fig:Spectators' Map-view Page}, Spectators are able to view  the participants' live position only during the run and time left for the race to end, because after the end of this time, spectators won't be able to view the map.
	
	\chapter{Requirements traceability}
	In this section is shown how the goals and requirements specified in the RASD are mapped to the design components defined in this document.
	
\begin{itemize}
	\item{\textbf{Data4Help}}
	\begin{enumerate}
		\requirement{1} The system must allow an individual to register a new account \\
		\textbf{D4H::SignupService}
		\requirement{2} The system must allow an individual to access to their account \\
		\textbf{D4H::LoginService}
		\requirement{3} The system must allow an individual to accept or reject their requests of accessing personal data \\
		\textbf{D4H::D4HRequestService}
		\requirement{4} The system must be able to communicate with TrackMe database in order to obtain the health status and location of an individual \\
		\textbf{D4H::SearchService}
		\requirement{5} The system must allow a third party company to register a new account \\								\textbf{D4H::SignupService}
		\requirement{6} The system must allow a third party company to access to its account 	\\								\textbf{D4H::LoginService}
		\requirement{7} The system must be able to notify the individual that a third party company wants to access its data \\
		\textbf{D4H::D4HRequestService}
		\requirement{8} The system must allow a third party company to search for an individual health status and location using his/her SSN \\
		 \textbf{D4H::SearchService}
		 \requirement{9} The system must allow a third party company to filter data of an anonymized group of individuals by location, age range, gender and blood type criteria \\ 
		 \textbf{D4H::SearchService}
		 \requirement{10} The system must be able to anonymize the data of a group of individuals \\
		 \textbf{D4H::APIManager}
		 \requirement{11} The system must subscribe a third party company to an individual health status and location when the request is approved by the individual \\ 
		\textbf{D4H::SubscriptionService}
		\requirement{12} The system must allow a third party company to subscribe to data of an anonymized group of individuals \\
		\textbf{D4H::SubscriptionService}
	\end{enumerate}	
		
	\item{\textbf{AutomatedSOS}}
	\begin{enumerate}
		\requirement{13} The system must be able to send a request for monitoring an individual's data when he/she is older than 60 years old \\
		\textbf{ASOS::DataService}
		\requirement{14} The system must be able to monitor, and compare against defined thresholds, the health status of an individual \\
		\textbf{ASOS::DataService}
		\requirement{15} The system must be able to contact the health-care service associated to an individual \\
		\textbf{ASOS::APIManager}
	\end{enumerate}
	
	\item{\textbf{Track4Run}}
	\begin{enumerate}
		\requirement{16} The system must allow a participant to register a new account \\
		\textbf{T4R::Signup}
		\requirement{17} The system must allow a participant to access to their account \\
		\textbf{T4R::Login}
		\requirement{18} The system must allow an organizer to register a new account \\
		\textbf{T4R::Signup}
		\requirement{19} The system must allow an organizer to access to their account \\
		\textbf{T4R::Login}
		\requirement{20} The system must allow an organizer to create a race event \\ 
		\textbf{T4R::Event}
		\requirement{21} The system must allow an organizer to define the running circuit of a race event \\
		\textbf{T4R::Event}
		\requirement{22} The system must allow an organizer to send invitations to participants to enroll in a race event \\
		\textbf{T4R::Notification}
		\requirement{23} The system must allow a participant to accept or reject an invitation to a race \\
		\textbf{T4R::Notification, T4R::Request}
		\requirement{24} The system must allow any spectator of a run to view in a map the participants' location \\ 
		\textbf{T4R::DataHandler}
		\requirement{25} The system must allow a spectator to click on a participant location in order to view his/her health status \\
		\textbf{T4R::DataHandler}
	\end{enumerate}
\end{itemize}

	\chapter{Implementation, integration and test plan}
	\section{Requirements of implementation and testing}
In order to start implementation process of the project, RASD and DD must be finished and available for all the teams of the project, so they will be informed about requirements and adopted design choices. A good analysis of each document is also required to be sure that implemented system will be secure and reliable.\\

\textbf{Development Tools} The Java programming language is suggested to develop the system because it suits very well for communication among different platforms and devices. In addition, Java Standard Edition will be used to deploy our business functionalities and to build a reliable and powerful web tier to let users communicate with main server using a standard web browser. \\

\textbf{Testing Tools} In order to achieve all the testing purposes we recommend to use different testing tools:
\begin{itemize}
\item{} For unit testing of each component can be used \textit{JUnit} framework. It’s a good framework since it is well tested and supported. It can test each functionality of component into an isolated environment, and can be used also to test some little interaction between components.
\item{}\textit{Mockito} tool is suggested as it is a No expect-run-verify technique. It is another well known and highly used framework, in which the produced tests are very readable.
\item{} \textit{Grinder} software may be used to make load tests on Web Server.
\item{} \textit{HammerDB} may be used to test functionalities and performance of Database server.
\end{itemize}

\section{Implementation Strategy}
Implementation process will follow the bottom-up strategy: we plan to implement first single component isolated. Once at least 60\% of a component will be developed, its unit testing phase can start.\\

The implementation of the \textit{TrackMe} system will be done module by module and component by component. The order in which it is carried out depends on a number of factors like the complexity of the modules and services, the dependence of other modules on the component being implemented and to the system as a whole, and it should also take into account the possibility of discovering flaws with the proposed design. The later should be dealt in a way that, if such an unfortunate event does	happen, the flaws should be found and corrected as soon as possible, to limit the cost of the change of design. Identify here the order in which system plan to implement the subcomponents of your system and the order in which system plan to integrate such subcomponents and test the integration.\\

\subsection{Implementation order}
Due to modularity of system components and to the adopted strategy there are no constraints on implementation order of components. But due to some critical aspects of a few components we want to prioritize implementation of those components.\\

The most critical components of the system that could take more than others to be implemented may be:
\begin{enumerate}
\item{} DBManager, AuthenticationManager, LoginService and SignupService
\item{} RequestService, SubscriptionService, NotificationService
\item{} SearchService, DataService
\item{} APIManager, UserService
\item{} AutomatedSOSDB, TokenDB, Track4RunDB, Data4HelpDB
\end{enumerate}
(note that by specifying the names of interfaces of components, we are also considering the concrete implementations, in whichever number they exist)\\

\section{Integration and Testing}
\subsection{Entry criteria} 
The integration of components and its testing should start as soon as possible, but before they can commence, some conditions must be met. First of all, the external services and their APIs that are going to be used in the application should be available and ready. This applies to the already mentioned services, to the DBMS and the server on which it will be running on. \\

Next, the modules which are being integrated should have at least the operations concerning one another created, if not completed completely. The operations that have been developed should pass the unit tests in order to be sure that the components are working fine on their own and that if an integration test fails, the problem lies in the in the integration itself.\\

\subsection{Integration test strategy}  
The main goal of integration process is to avoid as much errors as possible at each step of the process, so the system will incrementally integrate components as soon as they are completely developed and released.\\

\textit{Bottom-up} design will be adopted for most of the integration process: at the beginning only components that have less bindings to other components or which can work without other component will be integrated. In this way we can obtain feedbacks about system functionalities as soon as components are released and in addition we can parallelize integration of different subsections of the system.\\

For the most critical components or for more complex system parts we will use instead \textit{Critical Modules strategy}: components that fit very well for \textit{Critical Modules} strategy are those in Data4Help subsystem, because the AutomatedSOS and Track4Run will use the Data4Help system and are the most frequent interaction performed into our system. For this reason \textit{Bottom-Up} strategy will be applied only once Data4Help subsystem will be fully integrated using \textit{Critical Modules}.

\subsection{Integration order}
In this section, the list and order of every integration that is performed is shown. As already stated, the integration will be performed from the bottom-up. \\

It should be noted that there will be no explicit integration of the Data4Help Backend, Track4Run Backend with any of the other components. This is because the nature of the component, the extent of the usage and dependency of other components on it and the implementation plan, that clearly states that the Data4Help Backend will be the first part that is implemented, mean that the integration itself is already being done during the implementation phase of the depending components and its correctness will inherently be tested by the unit tests of each component.
\begin{enumerate}
\item{} As written in the introduction, at the beginning we will integrate the \textit{Data4Help} subsystem, composed by these components:
\begin{itemize}
\item{} Data4Help Web Site
\item{} DBManager, AuthenticationManager, LoginService and SignupService
\item{} RequestService, SubscriptionService
\item{} SearchManager, UserService, DataService
\item{} Schedulers
\end{itemize}

Integration tests will check cases like addition of new user to database, accessing the system with correct credentials, the consistency of making request, the reachability of all notifications to accept/reject request in the dashboard, the modification of subscription chosen by the user (if he wants any).

\item{} Then we could start to implement part of the \textit{AutomatedSOS} subsystem:
\begin{itemize}
\item{} DataService, DBManager
\item{} APIManager 
\end{itemize}
This integration step will check the communication of the Data4Help system with external sources HealthCareService when the vital signs are out of the normal range.

\item{} Then we could start to implement part of the \textit{Track4Run} subsystem:
\begin{itemize}
\item{} Track4RunWebService
\item{} Track4RunDB 
\item{} RunCollection
\item{} TokenService, OrganizerCollection and ParticipantCollection
\end{itemize}
This integration step will check the communication of the Data4Help system with Track4RunWebService and when RunCollection is modified, check the integration with the existing requestService and notificationService of Data4HelpWebService.

\item{} After that, other components can be joined together into small subsystems to test their interactions:
\begin{itemize}
\item{} \textit{AuthenticationManager} and \textit{LoginService} : their interactions must not brake the consistency of Account information and they have to check only authorized users can access information
\item{} \textit{SearchManager, RequestService} and \textit{SubscriptionService} : system will check consistency between search into a request and subscription of the same user
\item{} \textit{DataService, DBManager} and \textit{APIManager} : system will continuously check latest data and verify with the thresholds, if varies, notifies HealthCareService through APIManager of the same user
\item{} \textit{RunCollection} and \textit{ParticipantCollection} : system will check consistency between run created and allows users participated in the same run
\end{itemize}

\item{} After that we can start to integrate user interactions:
\begin{itemize}
\item{} \textit{UserInterface} and \textit{RequestService} : tests sending request for specific or anonymized search through different user interfaces
\item{} \textit{UserInterface} and \textit{NotificationService} : tests will check asynchronous communication between user and server for the dispatch of event messages
\item{} \textit{UserInterface} and \textit{RunCollection} : tests will check asynchronous communication between user and runs available for the live view on the map of participants
\item{} \textit{UserInterface} and \textit{HealthCareService} External Resource : will tests the communication
with external services of User Interface and Health-Care Service
and the synchronization of Data with threshold values when user's data is out of range, notifies using external alarm interfaces
\end{itemize}
\end{enumerate}
	
	\chapter{Effort spent}
	\begin{table}[h]
		\centering
		\begin{tabular}{l c}
			\hline\hline
			\multicolumn{2}{c}{\textbf{Team Work}} \\
			\hline
			\textbf{Task} & \textbf{Hours} \\ [0.5ex]
			\hline
			Planning Architecture & 8  \\
			Architectural design overview & 4\\
			Choosing Patterns & 3\\
			Checking document  & 2  \\
			\hline
			\textbf{Total} & 17  \\
			\hline
		\end{tabular}
		\caption{Time spent by all team members}
		\label{fig:Time spent by all team members}
	\end{table}
	
	\begin{table}[h]
		\centering
		\begin{tabular}{l c l c l c}
			\hline\hline
			\multicolumn{6}{c}{\textbf{Individual Work}} \\
			\hline
			\multicolumn{2}{c |}{\textbf{Diego Avila}}  &
			\multicolumn{2}{c |}{\textbf{Laura Schiatti}} &
			\multicolumn{2}{c}{\textbf{Sukhpreet Kaur}}  \\
			\hline
			\textbf{Task} & \textbf{Hours}
			& \textbf{Task} & \textbf{Hours}
			& \textbf{Task} & \textbf{Hours} \\ [0.5ex]
			\hline
			Component view &  11
			& Scope & 3
			& Purpose & 2  \\
			\hline
			Component interfaces &  14
			& Database view & 6
			& UI design & 15  \\
			\hline
			Deployment view &  6
			& Runtime view & 8
			& I and T plan & 6  \\
			\hline
			Runtime view  &  4
			& R traceability & 3
			& Design decisions & 2 \\
			\hline
			Corrections & 4  
			& Final user interfaces & 7
			& &   \\
			\hline 
			&  
			& Architectural styles & 4
			& &   \\
			\hline
			\textbf{Total} & 39
			& \textbf{Total} & 31
			& \textbf{Total} & 25  \\
			\hline
		\end{tabular}
		\caption{Time spent by each team member}
		\label{fig:Time spent by each team member}
	\end{table}
	
	\chapter{References}
	\begin{itemize}
		\item Requirement Analysis and Specification Document: AA 2017-2018.pdf”. Version 1.0 - 26.10.2017
		\item Henriksen, A., Haugen Mikalsen, M., Woldaregay, A. Z., Muzny, M., Hartvigsen, G., Hopstock, L. A., Grimsgaard, S. (2018)
		\\Using Fitness Trackers and Smartwatches to Measure Physical Activity in Research: Analysis of Consumer Wrist-Worn Wearables. Journal of medical Internet research, 20(3), e110. doi:10.2196/jmir.9157.
		\\Retrieved from: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5887043/
		\item IEEE. (1993). IEEE Recommended Practice for Software Requirements Specifications (IEEE 830-1993).
		\\Retrieved from https://standards.ieee.org/standard/830-1993.html
		\item Sloane, A. M. (2009). Software Abstractions: Logic, Language, and Analysis by Jackson Daniel, The MIT Press, 2006, 366pp, ISBN 978-0262101141.
		\item{Spark. A Micro Framework For Creating Web Applications - http://sparkjava.com/}
		\item{Morphia - http://morphiaorg.github.io/morphia/}
		\item{Lettuce - https://lettuce.io/}
		\item{Angular - https://angular.io/}
		\item{Google Maps Platform - https://cloud.google.com/maps-platform/}
		
	\end{itemize}
	
\end{document}
